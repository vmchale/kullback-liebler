<!DOCTYPE HTML>
<html lang="en"><head><meta charset="utf-8"><title>prelude/soacs</title><link href="../../style.css" rel="stylesheet" type="text/css"></head><body><div id="header"><h1>prelude/soacs</h1><ul id="navigation"><li><a href="../../index.html">Contents</a></li><li><a href="../../doc-index.html">Index</a></li></ul></div><div id="content"><nav id="filenav"><ul><li><a href="../../doc/lib/github.com/vmchale/kullback-liebler/information.html">lib/github.com/vmchale/kullback-liebler/information</a></li></ul></nav><main><a id="abstract" href="#abstract" class="self_link"><h2>Abstract</h2></a><p>Various Second-Order Array Combinators that are operationally
parallel in a way that can be exploited by the compiler.</p>
<p>The functions here are all recognised specially by the compiler (or
built on those that are).  The asymptotic <a href="https://en.wikipedia.org/wiki/Analysis_of_parallel_algorithms">work and
span</a>
is provided for each function, but note that this easily hides very
substantial constant factors.  For example, <a href="#879"><code>scan</code></a> is <em>much</em>
slower than <a href="#845"><code>reduce</code></a>, although they have the same asymptotic
complexity.</p>
<p><strong>Higher-order complexity</strong></p>
<p>Specifying the time complexity of higher-order functions is tricky
because it depends on the functional argument.  We use the informal
convention that <em>W(f)</em> denotes the largest (asymptotic) <em>work</em> of
function <em>f</em>, for the values it may be applied to.  Similarly,
<em>S(f)</em> denotes the largest span.  See <a href="https://en.wikipedia.org/wiki/Analysis_of_parallel_algorithms">this Wikipedia
article</a>
for a general introduction to these constructs.</p>
<p><strong>Reminder on terminology</strong></p>
<p>A function <code>op</code> is said to be <em>associative</em> if</p>
<pre><code>(x `op` y) `op` z == x `op` (y `op` z)
</code></pre>
<p>for all <code>x</code>, <code>y</code>, <code>z</code>.  Similarly, it is <em>commutative</em> if</p>
<pre><code>x `op` y == y `op` x
</code></pre>
<p>The value <code>o</code> is a <em>neutral element</em> if</p>
<pre><code>x `op` o == o `op` x == x
</code></pre>
<p>for any <code>x</code>.</p>
<a id="synopsis" href="#synopsis" class="self_link"><h2>Synopsis</h2></a><div id="overview"><div id="module"><table class="specs"><tr><td></td><td></td><td></td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="712s"><a href="#712">map</a></span></span></td><td class="spec_eql"> &#39;<span id="702">a</span> [<span id="703">n</span>] &#39;<span id="704">x</span> : </td><td class="spec_rhs">(<span id="705">f</span>: a -&gt; x) -&gt; (<span id="706">as</span>: [n]a) -&gt; *[n]x</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="722s"><a href="#722">map1</a></span></span></td><td class="spec_eql"> &#39;<span id="713">a</span> [<span id="714">n</span>] &#39;<span id="715">x</span> : </td><td class="spec_rhs">(<span id="716">f</span>: a -&gt; x) -&gt; (<span id="717">as</span>: [n]a) -&gt; *[n]x</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="743s"><a href="#743">map2</a></span></span></td><td class="spec_eql"> &#39;<span id="723">a</span> &#39;<span id="724">b</span> [<span id="725">n</span>] &#39;<span id="726">x</span> : </td><td class="spec_rhs">(<span id="727">f</span>: a -&gt; b -&gt; x) -&gt; (<span id="728">as</span>: [n]a) -&gt; (<span id="729">bs</span>: [n]b) -&gt; *[n]x</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="769s"><a href="#769">map3</a></span></span></td><td class="spec_eql"> &#39;<span id="744">a</span> &#39;<span id="745">b</span> &#39;<span id="746">c</span> [<span id="747">n</span>] &#39;<span id="748">x</span> : </td><td class="spec_rhs">(<span id="749">f</span>: a -&gt; b -&gt; c -&gt; x) -&gt; (<span id="750">as</span>: [n]a) -&gt; (<span id="751">bs</span>: [n]b) -&gt; (<span id="752">cs</span>: [n]c) -&gt; *[n]x</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="800s"><a href="#800">map4</a></span></span></td><td class="spec_eql"> &#39;<span id="770">a</span> &#39;<span id="771">b</span> &#39;<span id="772">c</span> &#39;<span id="773">d</span> [<span id="774">n</span>] &#39;<span id="775">x</span> : </td><td class="spec_rhs">(<span id="776">f</span>: a -&gt; b -&gt; c -&gt; d -&gt; x) -&gt; (<span id="777">as</span>: [n]a) -&gt; (<span id="778">bs</span>: [n]b) -&gt; (<span id="779">cs</span>: [n]c) -&gt; (<span id="780">ds</span>: [n]d) -&gt; *[n]x</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="836s"><a href="#836">map5</a></span></span></td><td class="spec_eql"> &#39;<span id="801">a</span> &#39;<span id="802">b</span> &#39;<span id="803">c</span> &#39;<span id="804">d</span> &#39;<span id="805">e</span> [<span id="806">n</span>] &#39;<span id="807">x</span> : </td><td class="spec_rhs">(<span id="808">f</span>: a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; x) -&gt; (<span id="809">as</span>: [n]a) -&gt; (<span id="810">bs</span>: [n]b) -&gt; (<span id="811">cs</span>: [n]c) -&gt; (<span id="812">ds</span>: [n]d) -&gt; (<span id="813">es</span>: [n]e) -&gt; *[n]x</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="845s"><a href="#845">reduce</a></span></span></td><td class="spec_eql"> [<span id="837">n</span>] &#39;<span id="838">a</span> : </td><td class="spec_rhs">(<span id="839">op</span>: a -&gt; a -&gt; a) -&gt; (<span id="840">ne</span>: a) -&gt; (<span id="841">as</span>: [n]a) -&gt; a</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="854s"><a href="#854">reduce_comm</a></span></span></td><td class="spec_eql"> [<span id="846">n</span>] &#39;<span id="847">a</span> : </td><td class="spec_rhs">(<span id="848">op</span>: a -&gt; a -&gt; a) -&gt; (<span id="849">ne</span>: a) -&gt; (<span id="850">as</span>: [n]a) -&gt; a</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="869s"><a href="#869">reduce_by_index</a></span></span></td><td class="spec_eql"> &#39;<span id="855">a</span> [<span id="856">m</span>] [<span id="857">n</span>] : </td><td class="spec_rhs">(<span id="858">dest</span>: *[m]a) -&gt; (<span id="859">f</span>: a -&gt; a -&gt; a) -&gt; (<span id="860">ne</span>: a) -&gt; (<span id="861">is</span>: [n]i64) -&gt; (<span id="862">as</span>: [n]a) -&gt; *[m]a</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="879s"><a href="#879">scan</a></span></span></td><td class="spec_eql"> [<span id="870">n</span>] &#39;<span id="871">a</span> : </td><td class="spec_rhs">(<span id="872">op</span>: a -&gt; a -&gt; a) -&gt; (<span id="873">ne</span>: a) -&gt; (<span id="874">as</span>: [n]a) -&gt; *[n]a</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="903s"><a href="#903">filter</a></span></span></td><td class="spec_eql"> [<span id="880">n</span>] &#39;<span id="881">a</span> : </td><td class="spec_rhs">(<span id="882">p</span>: a -&gt; bool) -&gt; (<span id="883">as</span>: [n]a) -&gt; *[]a</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="936s"><a href="#936">partition</a></span></span></td><td class="spec_eql"> [<span id="904">n</span>] &#39;<span id="905">a</span> : </td><td class="spec_rhs">(<span id="906">p</span>: a -&gt; bool) -&gt; (<span id="907">as</span>: [n]a) -&gt; ([]a, []a)</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="989s"><a href="#989">partition2</a></span></span></td><td class="spec_eql"> [<span id="937">n</span>] &#39;<span id="938">a</span> : </td><td class="spec_rhs">(<span id="939">p1</span>: a -&gt; bool) -&gt; (<span id="940">p2</span>: a -&gt; bool) -&gt; (<span id="941">as</span>: [n]a) -&gt; ([]a, []a, []a)</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="1001s"><a href="#1001">reduce_stream</a></span></span></td><td class="spec_eql"> [<span id="990">n</span>] &#39;<span id="991">a</span> &#39;<span id="992">b</span> : </td><td class="spec_rhs">(<span id="993">op</span>: b -&gt; b -&gt; b) -&gt; (<span id="995">f</span>: (<span id="994">k</span>: i64) -&gt; [<a href="#994">k</a>]a -&gt; b) -&gt; (<span id="996">as</span>: [n]a) -&gt; b</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="1013s"><a href="#1013">reduce_stream_per</a></span></span></td><td class="spec_eql"> [<span id="1002">n</span>] &#39;<span id="1003">a</span> &#39;<span id="1004">b</span> : </td><td class="spec_rhs">(<span id="1005">op</span>: b -&gt; b -&gt; b) -&gt; (<span id="1007">f</span>: (<span id="1006">k</span>: i64) -&gt; [<a href="#1006">k</a>]a -&gt; b) -&gt; (<span id="1008">as</span>: [n]a) -&gt; b</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="1025s"><a href="#1025">map_stream</a></span></span></td><td class="spec_eql"> [<span id="1014">n</span>] &#39;<span id="1015">a</span> &#39;<span id="1016">b</span> : </td><td class="spec_rhs">(<span id="1018">f</span>: (<span id="1017">k</span>: i64) -&gt; [<a href="#1017">k</a>]a -&gt; [<a href="#1017">k</a>]b) -&gt; (<span id="1019">as</span>: [n]a) -&gt; *[n]b</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="1037s"><a href="#1037">map_stream_per</a></span></span></td><td class="spec_eql"> [<span id="1026">n</span>] &#39;<span id="1027">a</span> &#39;<span id="1028">b</span> : </td><td class="spec_rhs">(<span id="1030">f</span>: (<span id="1029">k</span>: i64) -&gt; [<a href="#1029">k</a>]a -&gt; [<a href="#1029">k</a>]b) -&gt; (<span id="1031">as</span>: [n]a) -&gt; *[n]b</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="1049s"><a href="#1049">all</a></span></span></td><td class="spec_eql"> [<span id="1038">n</span>] &#39;<span id="1039">a</span> : </td><td class="spec_rhs">(<span id="1040">f</span>: a -&gt; bool) -&gt; (<span id="1041">as</span>: [n]a) -&gt; bool</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="1061s"><a href="#1061">any</a></span></span></td><td class="spec_eql"> [<span id="1050">n</span>] &#39;<span id="1051">a</span> : </td><td class="spec_rhs">(<span id="1052">f</span>: a -&gt; bool) -&gt; (<span id="1053">as</span>: [n]a) -&gt; bool</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="1073s"><a href="#1073">scatter</a></span></span></td><td class="spec_eql"> &#39;<span id="1062">t</span> [<span id="1063">m</span>] [<span id="1064">n</span>] : </td><td class="spec_rhs">(<span id="1065">dest</span>: *[m]t) -&gt; (<span id="1066">is</span>: [n]i64) -&gt; (<span id="1067">vs</span>: [n]t) -&gt; *[m]t</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="1088s"><a href="#1088">scatter_2d</a></span></span></td><td class="spec_eql"> &#39;<span id="1074">t</span> [<span id="1075">m</span>] [<span id="1076">n</span>] [<span id="1077">l</span>] : </td><td class="spec_rhs">(<span id="1078">dest</span>: *[m][n]t) -&gt; (<span id="1079">is</span>: [l](i64, i64)) -&gt; (<span id="1080">vs</span>: [l]t) -&gt; *[m][n]t</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="1106s"><a href="#1106">scatter_3d</a></span></span></td><td class="spec_eql"> &#39;<span id="1089">t</span> [<span id="1090">m</span>] [<span id="1091">n</span>] [<span id="1092">o</span>] [<span id="1093">l</span>] : </td><td class="spec_rhs">(<span id="1094">dest</span>: *[m][n][o]t) -&gt; (<span id="1095">is</span>: [l](i64, i64, i64)) -&gt; (<span id="1096">vs</span>: [l]t) -&gt; *[m][n][o]t</td></tr></table></div></div><a id="description" href="#description" class="self_link"><h2>Description</h2></a><dl><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#712s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="712">map</a></span></span> &#39;<span id="702">a</span> [<span id="703">n</span>] &#39;<span id="704">x</span>: (<span id="705">f</span>: a -&gt; x) -&gt; (<span id="706">as</span>: [n]a) -&gt; *[n]x</dt><dd class="desc_doc"><p>Apply the given function to each element of an array.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(f))</em></p>
<p><strong>Span:</strong> <em>O(S(f))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#722s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="722">map1</a></span></span> &#39;<span id="713">a</span> [<span id="714">n</span>] &#39;<span id="715">x</span>: (<span id="716">f</span>: a -&gt; x) -&gt; (<span id="717">as</span>: [n]a) -&gt; *[n]x</dt><dd class="desc_doc"><p>Apply the given function to each element of a single array.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(f))</em></p>
<p><strong>Span:</strong> <em>O(S(f))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#743s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="743">map2</a></span></span> &#39;<span id="723">a</span> &#39;<span id="724">b</span> [<span id="725">n</span>] &#39;<span id="726">x</span>: (<span id="727">f</span>: a -&gt; b -&gt; x) -&gt; (<span id="728">as</span>: [n]a) -&gt; (<span id="729">bs</span>: [n]b) -&gt; *[n]x</dt><dd class="desc_doc"><p>As <a href="#722"><code>map1</code></a>, but with one more array.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(f))</em></p>
<p><strong>Span:</strong> <em>O(S(f))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#769s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="769">map3</a></span></span> &#39;<span id="744">a</span> &#39;<span id="745">b</span> &#39;<span id="746">c</span> [<span id="747">n</span>] &#39;<span id="748">x</span>: (<span id="749">f</span>: a -&gt; b -&gt; c -&gt; x) -&gt; (<span id="750">as</span>: [n]a) -&gt; (<span id="751">bs</span>: [n]b) -&gt; (<span id="752">cs</span>: [n]c) -&gt; *[n]x</dt><dd class="desc_doc"><p>As <a href="#743"><code>map2</code></a>, but with one more array.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(f))</em></p>
<p><strong>Span:</strong> <em>O(S(f))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#800s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="800">map4</a></span></span> &#39;<span id="770">a</span> &#39;<span id="771">b</span> &#39;<span id="772">c</span> &#39;<span id="773">d</span> [<span id="774">n</span>] &#39;<span id="775">x</span>: (<span id="776">f</span>: a -&gt; b -&gt; c -&gt; d -&gt; x) -&gt; (<span id="777">as</span>: [n]a) -&gt; (<span id="778">bs</span>: [n]b) -&gt; (<span id="779">cs</span>: [n]c) -&gt; (<span id="780">ds</span>: [n]d) -&gt; *[n]x</dt><dd class="desc_doc"><p>As <a href="#769"><code>map3</code></a>, but with one more array.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(f))</em></p>
<p><strong>Span:</strong> <em>O(S(f))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#836s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="836">map5</a></span></span> &#39;<span id="801">a</span> &#39;<span id="802">b</span> &#39;<span id="803">c</span> &#39;<span id="804">d</span> &#39;<span id="805">e</span> [<span id="806">n</span>] &#39;<span id="807">x</span>: (<span id="808">f</span>: a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; x) -&gt; (<span id="809">as</span>: [n]a) -&gt; (<span id="810">bs</span>: [n]b) -&gt; (<span id="811">cs</span>: [n]c) -&gt; (<span id="812">ds</span>: [n]d) -&gt; (<span id="813">es</span>: [n]e) -&gt; *[n]x</dt><dd class="desc_doc"><p>As <a href="#769"><code>map3</code></a>, but with one more array.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(f))</em></p>
<p><strong>Span:</strong> <em>O(S(f))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#845s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="845">reduce</a></span></span> [<span id="837">n</span>] &#39;<span id="838">a</span>: (<span id="839">op</span>: a -&gt; a -&gt; a) -&gt; (<span id="840">ne</span>: a) -&gt; (<span id="841">as</span>: [n]a) -&gt; a</dt><dd class="desc_doc"><p>Reduce the array <code>as</code> with <code>op</code>, with <code>ne</code> as the neutral
element for <code>op</code>.  The function <code>op</code> must be associative.  If
it is not, the return value is unspecified.  If the value returned
by the operator is an array, it must have the exact same size as
the neutral element, and that must again have the same size as the
elements of the input array.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(op))</em></p>
<p><strong>Span:</strong> <em>O(log(n) ✕ W(op))</em></p>
<p>Note that the complexity implies that parallelism in the combining
operator will <em>not</em> be exploited.</p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#854s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="854">reduce_comm</a></span></span> [<span id="846">n</span>] &#39;<span id="847">a</span>: (<span id="848">op</span>: a -&gt; a -&gt; a) -&gt; (<span id="849">ne</span>: a) -&gt; (<span id="850">as</span>: [n]a) -&gt; a</dt><dd class="desc_doc"><p>As <code>reduce</code>, but the operator must also be commutative.  This is
potentially faster than <code>reduce</code>.  For simple built-in operators,
like addition, the compiler already knows that the operator is
commutative, so plain <a href="#845"><code>reduce</code></a> will work just as well.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(op))</em></p>
<p><strong>Span:</strong> <em>O(log(n) ✕ W(op))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#869s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="869">reduce_by_index</a></span></span> &#39;<span id="855">a</span> [<span id="856">m</span>] [<span id="857">n</span>]: (<span id="858">dest</span>: *[m]a) -&gt; (<span id="859">f</span>: a -&gt; a -&gt; a) -&gt; (<span id="860">ne</span>: a) -&gt; (<span id="861">is</span>: [n]i64) -&gt; (<span id="862">as</span>: [n]a) -&gt; *[m]a</dt><dd class="desc_doc"><p><code>reduce_by_index dest f ne is as</code> returns <code>dest</code>, but with each
element given by the indices of <code>is</code> updated by applying <code>f</code> to the
current value in <code>dest</code> and the corresponding value in <code>as</code>.  The
<code>ne</code> value must be a neutral element for <code>f</code>.  If <code>is</code> has
duplicates, <code>f</code> may be applied multiple times, and hence must be
associative and commutative.  Out-of-bounds indices in <code>is</code> are
ignored.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(op))</em></p>
<p><strong>Span:</strong> <em>O(n ✕ W(op))</em> in the worst case (all updates to same
position), but <em>O(W(op))</em> in the best case.</p>
<p>In practice, the <em>O(n)</em> behaviour only occurs if <em>m</em> is also very
large.</p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#879s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="879">scan</a></span></span> [<span id="870">n</span>] &#39;<span id="871">a</span>: (<span id="872">op</span>: a -&gt; a -&gt; a) -&gt; (<span id="873">ne</span>: a) -&gt; (<span id="874">as</span>: [n]a) -&gt; *[n]a</dt><dd class="desc_doc"><p>Inclusive prefix scan.  Has the same caveats with respect to
associativity and complexity as <code>reduce</code>.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(op))</em></p>
<p><strong>Span:</strong> <em>O(log(n) ✕ W(op))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#903s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="903">filter</a></span></span> [<span id="880">n</span>] &#39;<span id="881">a</span>: (<span id="882">p</span>: a -&gt; bool) -&gt; (<span id="883">as</span>: [n]a) -&gt; *[]a</dt><dd class="desc_doc"><p>Remove all those elements of <code>as</code> that do not satisfy the
predicate <code>p</code>.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(p))</em></p>
<p><strong>Span:</strong> <em>O(log(n) ✕ W(p))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#936s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="936">partition</a></span></span> [<span id="904">n</span>] &#39;<span id="905">a</span>: (<span id="906">p</span>: a -&gt; bool) -&gt; (<span id="907">as</span>: [n]a) -&gt; ([]a, []a)</dt><dd class="desc_doc"><p>Split an array into those elements that satisfy the given
predicate, and those that do not.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(p))</em></p>
<p><strong>Span:</strong> <em>O(log(n) ✕ W(p))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#989s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="989">partition2</a></span></span> [<span id="937">n</span>] &#39;<span id="938">a</span>: (<span id="939">p1</span>: a -&gt; bool) -&gt; (<span id="940">p2</span>: a -&gt; bool) -&gt; (<span id="941">as</span>: [n]a) -&gt; ([]a, []a, []a)</dt><dd class="desc_doc"><p>Split an array by two predicates, producing three arrays.</p>
<p><strong>Work:</strong> <em>O(n ✕ (W(p1) + W(p2)))</em></p>
<p><strong>Span:</strong> <em>O(log(n) ✕ (W(p1) + W(p2)))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#1001s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="1001">reduce_stream</a></span></span> [<span id="990">n</span>] &#39;<span id="991">a</span> &#39;<span id="992">b</span>: (<span id="993">op</span>: b -&gt; b -&gt; b) -&gt; (<span id="995">f</span>: (<span id="994">k</span>: i64) -&gt; [<a href="#994">k</a>]a -&gt; b) -&gt; (<span id="996">as</span>: [n]a) -&gt; b</dt><dd class="desc_doc"><p><code>reduce_stream op f as</code> splits <code>as</code> into chunks, applies <code>f</code> to each
of these in parallel, and uses <code>op</code> (which must be associative) to
combine the per-chunk results into a final result.  The <code>i64</code>
passed to <code>f</code> is the size of the chunk.  This SOAC is useful when
<code>f</code> can be given a particularly work-efficient sequential
implementation.  Operationally, we can imagine that <code>as</code> is divided
among as many threads as necessary to saturate the machine, with
each thread operating sequentially.</p>
<p>A chunk may be empty, and <code>f 0 []</code> must produce the neutral element for
<code>op</code>.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(op) + W(f))</em></p>
<p><strong>Span:</strong> <em>O(log(n) ✕ W(op))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#1013s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="1013">reduce_stream_per</a></span></span> [<span id="1002">n</span>] &#39;<span id="1003">a</span> &#39;<span id="1004">b</span>: (<span id="1005">op</span>: b -&gt; b -&gt; b) -&gt; (<span id="1007">f</span>: (<span id="1006">k</span>: i64) -&gt; [<a href="#1006">k</a>]a -&gt; b) -&gt; (<span id="1008">as</span>: [n]a) -&gt; b</dt><dd class="desc_doc"><p>As <a href="#1001"><code>reduce_stream</code></a>, but the chunks do not necessarily
correspond to subsequences of the original array (they may be
interleaved).</p>
<p><strong>Work:</strong> <em>O(n ✕ W(op) + W(f))</em></p>
<p><strong>Span:</strong> <em>O(log(n) ✕ W(op))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#1025s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="1025">map_stream</a></span></span> [<span id="1014">n</span>] &#39;<span id="1015">a</span> &#39;<span id="1016">b</span>: (<span id="1018">f</span>: (<span id="1017">k</span>: i64) -&gt; [<a href="#1017">k</a>]a -&gt; [<a href="#1017">k</a>]b) -&gt; (<span id="1019">as</span>: [n]a) -&gt; *[n]b</dt><dd class="desc_doc"><p>Similar to <a href="#1001"><code>reduce_stream</code></a>, except that each chunk must produce
an array <em>of the same size</em>.  The per-chunk results are
concatenated.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(f))</em></p>
<p><strong>Span:</strong> <em>O(S(f))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#1037s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="1037">map_stream_per</a></span></span> [<span id="1026">n</span>] &#39;<span id="1027">a</span> &#39;<span id="1028">b</span>: (<span id="1030">f</span>: (<span id="1029">k</span>: i64) -&gt; [<a href="#1029">k</a>]a -&gt; [<a href="#1029">k</a>]b) -&gt; (<span id="1031">as</span>: [n]a) -&gt; *[n]b</dt><dd class="desc_doc"><p>Similar to <a href="#1025"><code>map_stream</code></a>, but the chunks do not necessarily
correspond to subsequences of the original array (they may be
interleaved).</p>
<p><strong>Work:</strong> <em>O(n ✕ W(f))</em></p>
<p><strong>Span:</strong> <em>O(S(f))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#1049s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="1049">all</a></span></span> [<span id="1038">n</span>] &#39;<span id="1039">a</span>: (<span id="1040">f</span>: a -&gt; bool) -&gt; (<span id="1041">as</span>: [n]a) -&gt; bool</dt><dd class="desc_doc"><p>Return <code>true</code> if the given function returns <code>true</code> for all
elements in the array.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(f))</em></p>
<p><strong>Span:</strong> <em>O(log(n) + S(f))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#1061s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="1061">any</a></span></span> [<span id="1050">n</span>] &#39;<span id="1051">a</span>: (<span id="1052">f</span>: a -&gt; bool) -&gt; (<span id="1053">as</span>: [n]a) -&gt; bool</dt><dd class="desc_doc"><p>Return <code>true</code> if the given function returns <code>true</code> for any
elements in the array.</p>
<p><strong>Work:</strong> <em>O(n ✕ W(f))</em></p>
<p><strong>Span:</strong> <em>O(log(n) + S(f))</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#1073s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="1073">scatter</a></span></span> &#39;<span id="1062">t</span> [<span id="1063">m</span>] [<span id="1064">n</span>]: (<span id="1065">dest</span>: *[m]t) -&gt; (<span id="1066">is</span>: [n]i64) -&gt; (<span id="1067">vs</span>: [n]t) -&gt; *[m]t</dt><dd class="desc_doc"><p><code>scatter as is vs</code> calculates the equivalent of this imperative
code:</p>
<pre><code>for index in 0..length is-1:
  i = is[index]
  v = vs[index]
  as[i] = v
</code></pre>
<p>The <code>is</code> and <code>vs</code> arrays must have the same outer size.  <code>scatter</code>
acts in-place and consumes the <code>as</code> array, returning a new array
that has the same type and elements as <code>as</code>, except for the indices
in <code>is</code>.  If <code>is</code> contains duplicates (i.e. several writes are
performed to the same location), the result is unspecified.  It is
not guaranteed that one of the duplicate writes will complete
atomically - they may be interleaved.  See <a href="#869"><code>reduce_by_index</code></a>
for a function that can handle this case deterministically.</p>
<p>This is technically not a second-order operation, but it is defined
here because it is closely related to the SOACs.</p>
<p><strong>Work:</strong> <em>O(n)</em></p>
<p><strong>Span:</strong> <em>O(1)</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#1088s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="1088">scatter_2d</a></span></span> &#39;<span id="1074">t</span> [<span id="1075">m</span>] [<span id="1076">n</span>] [<span id="1077">l</span>]: (<span id="1078">dest</span>: *[m][n]t) -&gt; (<span id="1079">is</span>: [l](i64, i64)) -&gt; (<span id="1080">vs</span>: [l]t) -&gt; *[m][n]t</dt><dd class="desc_doc"><p><code>scatter_2d as is vs</code> is the equivalent of a <code>scatter</code> on a 2-dimensional
array.</p>
<p><strong>Work:</strong> <em>O(n)</em></p>
<p><strong>Span:</strong> <em>O(1)</em></p>
</dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#1106s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="1106">scatter_3d</a></span></span> &#39;<span id="1089">t</span> [<span id="1090">m</span>] [<span id="1091">n</span>] [<span id="1092">o</span>] [<span id="1093">l</span>]: (<span id="1094">dest</span>: *[m][n][o]t) -&gt; (<span id="1095">is</span>: [l](i64, i64, i64)) -&gt; (<span id="1096">vs</span>: [l]t) -&gt; *[m][n][o]t</dt><dd class="desc_doc"><p><code>scatter_3d as is vs</code> is the equivalent of a <code>scatter</code> on a 3-dimensional
array.</p>
<p><strong>Work:</strong> <em>O(n)</em></p>
<p><strong>Span:</strong> <em>O(1)</em></p>
</dd></div></dl></main></div><div id="footer">Generated by <a href="https://futhark.readthedocs.io/en/latest/man/futhark-doc.html">futhark-doc</a> 0.19.6</div></body></html>